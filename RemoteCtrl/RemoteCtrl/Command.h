#pragma once
#include "Resource.h"
#include <map>
#include "ServerSocket.h"
#include <atlimage.h>
#include <direct.h>
#include "ClassTool.h"
#include <stdio.h>
#include <io.h>
#include <list>
#include "LockDialog.h"
#include "Packet.h"
#pragma warning(disable:4966) //fopen sprintf strcpy strstr

class CCommand
{
public:
	CCommand();
	~CCommand() {};
	int ExcuteCommand(int nCmd, std::list<CPacket>& lstPacket,CPacket& inPacket);
    static void RunCommand(void* arg, int status,std::list<CPacket>& lstPacket, CPacket& inPacket) {
        CCommand* thiz = (CCommand*)arg;
        if (status > 0) {
            int ret = thiz->ExcuteCommand(status,lstPacket,inPacket);
            if (ret != 0) {
                TRACE("执行命令失败: %d ret=%d\r\n",status,ret);
            }
        }
        else {
            MessageBox(NULL, _T("无法正常接入用户，自动重试"), _T("接入用户失败！"), MB_OK | MB_ICONERROR);
        }

    }
protected:
	typedef int(CCommand::* CMDFUNC)(std::list<CPacket>&, CPacket& inPacket);//成员函数指针
	std::map<int, CMDFUNC> m_mapFunction;//函数映射表，从命令号到功能的映射，取代switch
    CLockDialog dlg;
    unsigned threadid;
protected:
    static unsigned __stdcall threadLockDlg(void* arg) {
        CCommand* thiz = (CCommand*)arg;
        thiz->threadLockDlgMain();
        _endthreadex(0);
        return 0;
    }

    void threadLockDlgMain() {
        TRACE("%s(%d):%d\r\n", __FUNCTION__, __LINE__, GetCurrentThreadId());
        dlg.Create(IDD_DIALOG_INFO, NULL);//创建一个由 IDD_DIALOG_INFO 标识的非模态对话框实例，并且这个对话框是一个顶级窗口，因为它没有指定父窗口
        dlg.ShowWindow(SW_SHOW);//让dlg对话框处于可见状态
        //窗口置顶

        CRect rect;

        rect.left = 0;
        rect.top = 0;
        rect.right = GetSystemMetrics(SM_CXFULLSCREEN);
        rect.bottom = GetSystemMetrics(SM_CYFULLSCREEN);
        rect.bottom = LONG(rect.bottom * 1.10);
        TRACE("right = %d bottom = %d\r\n", rect.right, rect.bottom);
        dlg.MoveWindow(rect);
        CWnd* pText = dlg.GetDlgItem(IDC_STATIC);
        if (pText) {
            CRect rtText;
            pText->GetWindowRect(rtText);
            int nWidth = rtText.Width();//w0
            int x = (rect.right - nWidth) / 2;
            int nHeight = rtText.Height();
            int y = (rect.bottom - nHeight) / 2;
            pText->MoveWindow(x, y, rtText.Width(), rtText.Height());
        }
        //窗口置顶
        dlg.SetWindowPos(&dlg.wndTopMost, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE);//将 dlg 对话框保持在所有窗口的最上层，但是不改变其大小和位置。
        //限制鼠标功能
        ShowCursor(false);//隐藏光标
        //隐藏任务栏
        ::ShowWindow(::FindWindow(_T("Shell_TrayWnd"), NULL), SW_HIDE);//寻找类名为 Shell_TrayWnd（即 Windows 任务栏）的窗口，然后通过 ShowWindow 函数将其设置为显示状态。这通常会导致原本隐藏的任务栏被显示出来。
        //限制鼠标活动范围
        dlg.GetWindowRect(rect);//GetWindowRect 函数获取了 dlg 窗口在屏幕上的位置和尺寸，再赋值给 rect
        rect.left = 0;
        rect.top = 0;
        rect.right = 1;
        rect.bottom = 1;
        //限制鼠标范围
        ClipCursor(rect);
        MSG msg;
        /*消息循环
        1 消息检索，从当前线程的消息队列中检索消息，如果队列为空，GetMessage 将会等待，直到有消息到来。
        2 消息翻译，翻译键盘输入消息，如按键消息转化为字符消息，这样就可以在窗口过程中正确处理键盘输入
        3 消息分派，将消息分发到对应的窗口过程，这个步骤实际上调用的是窗口关联的回调函数，函数通过分析消息并执行相应的操作来处理它们
        */

        while (GetMessage(&msg, NULL, 0, 0)) {//从程序的消息队列中取得用户的输入和其他事件,这个函数会阻塞，直到有消息可取
            TranslateMessage(&msg);//翻译虚拟键（如方向键、功能键等）到字符消息。
            DispatchMessage(&msg);//把消息分发给窗口程序的窗口过程函数，进行消息处理
            if (msg.message == WM_KEYDOWN) {
                TRACE("msg:%08X wparam:%08X lparam:%08X\r\n", msg.message, msg.wParam, msg.lParam);
                if (msg.wParam == 0x41) {//按ESC退出
                    break;
                }
            }
        }
        //恢复鼠标范围
        ClipCursor(NULL);
        //恢复鼠标
        ShowCursor(true);
        //恢复任务栏
        ::ShowWindow(::FindWindow(_T("Shell_TrayWnd"), NULL), SW_SHOW);//寻找类名为 Shell_TrayWnd（即 Windows 任务栏）的窗口，然后通过 ShowWindow 函数将其设置为显示状态。这通常会导致原本隐藏的任务栏被显示出来。
        dlg.DestroyWindow();
    }
    int MakeDriverInfo(std::list<CPacket>& lstPacket, CPacket& inPacket) {//创建裆前系统可用的磁盘分区信息,1代表A盘，2代表B盘...26代表Z盘
        std::string result;//存储结果字符串
        for (int i = 1; i <= 26; i++) {
            int ret = _chdrive(i);
            if (ret == 0) {//成功改变当前活动的驱动器
                if (result.size() > 0)
                    result += ',';
                result += 'A' + i - 1;
            }
        }
        lstPacket.push_back(CPacket(1, (BYTE*)result.c_str(), result.size()));
        return 0;
    }

    int MakeDirectoryInfo(std::list<CPacket>& lstPacket, CPacket& inPacket) {//用来收集特定路径下的文件和目录信息，并在发生错误的时候输出调试信息
        std::string strPath = inPacket.strData;
        //std::initializer_list<FILEINFO> lstFileInfos;
        if (_chdir(strPath.c_str()) != 0) {//更改当前工作目录为strpath指向的路径
            //_chdir:更改当前的工作目录
            FILEINFO finfo;//当目录由于权限不足无法切换时
            finfo.HasNext = FALSE;
            lstPacket.push_back(CPacket(2, (BYTE*)&finfo, sizeof(finfo)));
            OutputDebugString(_T("没有权限访问目录"));
            return -2;
        }
        _finddata_t fdata;//存储文件查找信息
        int hfind = 0;
        if ((hfind = _findfirst("*", &fdata)) == -1) {
            OutputDebugString(_T("没有找到任何文件"));
            FILEINFO finfo;
            finfo.HasNext = FALSE;
            lstPacket.push_back(CPacket(2, (BYTE*)&finfo, sizeof(finfo)));
            return -3;
        }
        int count = 0;
        do {
            FILEINFO finfo;
            finfo.IsDirectory = (fdata.attrib & _A_SUBDIR) != 0;//判断当前处理的文件项是不是目录
            memcpy(finfo.szFileName, fdata.name, strlen(fdata.name));
            TRACE("%s\r\n", finfo.szFileName);
            lstPacket.push_back(CPacket(2, (BYTE*)&finfo, sizeof(finfo)));
            count++;
        } while (!_findnext(hfind, &fdata));//获取下一个文件项信息
        TRACE("server: count = %d\r\n", count);
        //发送信息到客户端 
        FILEINFO finfo;
        finfo.HasNext = FALSE;
        lstPacket.push_back(CPacket(2, (BYTE*)&finfo, sizeof(finfo)));
        return 0;
    }

    int RunFile(std::list<CPacket>& lstPacket, CPacket& inPacket) {
        std::string strPath = inPacket.strData;
        ShellExecuteA(NULL, NULL, strPath.c_str(), NULL, NULL, SW_SHOWNORMAL);//将在用户的机器上运行一个程序或打开一个文件，具体行为取决于文件类型的关联程序。比如，如果路径是一个可执行文件，则会运行该程序；如果路径是文档文件，则会打开与之关联的应用程序查看该文档。
        /*
        ShellExecuteA(NULL, NULL, strPath.c_str(), NULL, NULL, SW_SHOWNORMAL);：调用 Win32 API 函数 ShellExecuteA 来执行或打开 strPath 变量中的文件。此函数的参数解释如下：
        NULL：表示函数不需要使用窗口句柄。
        NULL：操作设为 NULL 表示执行文件，默认操作通常是“打开”。
        strPath.c_str()：指定要运行或打开的文件的路径。
        NULL：没有要传递给要执行的程序的参数。
        NULL：默认目录设置为 NULL，所以执行文件时会使用它的默认目录。
        SW_SHOWNORMAL：指定窗口的显示方式，SW_SHOWNORMAL 为普通窗口大小。
        */
        lstPacket.push_back(CPacket(3, NULL, 0));
        return 0;
    }


    int DownloadFile(std::list<CPacket>& lstPacket, CPacket& inPacket) {//下载文件，即把文件从服务端发送到客户端
        std::string strPath = inPacket.strData;
        long long data = 0;
        FILE* pFile = NULL;
        errno_t err = fopen_s(&pFile, strPath.c_str(), "rb");//rb:二进制读取模式，文件指针pfile
        if (err != 0) {//打开文件失败
            lstPacket.push_back(CPacket(4, (BYTE*)&data, 8));
            return -1;
        }
        if (pFile != NULL) {
            fseek(pFile, 0, SEEK_END);//用fseek函数将文件指针pfile移动到文件末尾
            data = _ftelli64(pFile);//_ftelli64：获取文件大小
            lstPacket.push_back(CPacket(4, (BYTE*)&data, 8));
            fseek(pFile, 0, SEEK_SET);//用fseek函数将文件指针pfile定位到文件起始位置
            char buffer[1024] = "";
            size_t rlen = 0;//fread返回值
            do {
                rlen = fread(buffer, 1, 1024, pFile);//在buffer里读，一次读1字节，读1024次
                lstPacket.push_back(CPacket(4, (BYTE*)&data, 8));
            } while (rlen >= 1024);
            fclose(pFile);
        }
        lstPacket.push_back(CPacket(4, (BYTE*)&data, 8));
        return 0;
    }

    int MouseEvent(std::list<CPacket>& lstPacket, CPacket& inPacket) {//处理鼠标事件
        MOUSEEV mouse;
        memcpy(&mouse, inPacket.strData.c_str(), sizeof(MOUSEEV));
        DWORD nFlags = 0;//根据鼠标的按钮和操作设置标志位

        switch (mouse.nButton) {
        case 0://左键
            nFlags = 1;
            break;
        case 1://右键
            nFlags = 2;
            break;
        case 2://中键
            nFlags = 4;
            break;
        case 4://没有按键
            nFlags = 8;
            break;
        }
        if (nFlags != 8)
            SetCursorPos(mouse.ptXY.x, mouse.ptXY.y);//将光标移动到鼠标事件指定的屏幕坐标
        switch (mouse.nAction)
        {
            //nFlags 之前存储了哪个鼠标按钮被按下的信息，通过|=再加上鼠标动作的信息（二进制高位低位）
        case 0://单击
            nFlags |= 0x10;
            break;
        case 1://双击
            nFlags |= 0x20;
            break;
        case 2://按下
            nFlags |= 0x40;
            break;
        case 3://放开
            nFlags |= 0x80;
            break;
        default:
            break;
        }
        TRACE("mouse event : %08X x %d y %d \r\n", nFlags, mouse.ptXY.x, mouse.ptXY.y);
        switch (nFlags)
        {
        case 0x21://左键双击
            mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, GetMessageExtraInfo());
            mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, GetMessageExtraInfo());
        case 0x11://左键单击
            mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, GetMessageExtraInfo());
            mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, GetMessageExtraInfo());
            break;
        case 0x41://左键按下
            mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, GetMessageExtraInfo());
            break;
        case 0x81://左键放开
            mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, GetMessageExtraInfo());
            break;
        case 0x22://右键双击
            mouse_event(MOUSEEVENTF_RIGHTDOWN, 0, 0, 0, GetMessageExtraInfo());
            mouse_event(MOUSEEVENTF_RIGHTUP, 0, 0, 0, GetMessageExtraInfo());
        case 0x12://右键单击
            mouse_event(MOUSEEVENTF_RIGHTDOWN, 0, 0, 0, GetMessageExtraInfo());
            mouse_event(MOUSEEVENTF_RIGHTUP, 0, 0, 0, GetMessageExtraInfo());
            break;
        case 0x42://右键按下
            mouse_event(MOUSEEVENTF_RIGHTDOWN, 0, 0, 0, GetMessageExtraInfo());
            break;
        case 0x82://右键放开
            mouse_event(MOUSEEVENTF_RIGHTUP, 0, 0, 0, GetMessageExtraInfo());
            break;
        case 0x24://中键双击
            mouse_event(MOUSEEVENTF_MIDDLEDOWN, 0, 0, 0, GetMessageExtraInfo());
            mouse_event(MOUSEEVENTF_MIDDLEUP, 0, 0, 0, GetMessageExtraInfo());
        case 0x14://中键单击
            mouse_event(MOUSEEVENTF_MIDDLEDOWN, 0, 0, 0, GetMessageExtraInfo());
            mouse_event(MOUSEEVENTF_MIDDLEUP, 0, 0, 0, GetMessageExtraInfo());
            break;

        case 0x44://中键按下
            mouse_event(MOUSEEVENTF_MIDDLEDOWN, 0, 0, 0, GetMessageExtraInfo());
            break;
        case 0x84://中键放开
            mouse_event(MOUSEEVENTF_MIDDLEUP, 0, 0, 0, GetMessageExtraInfo());
            break;
        case 0x08://单纯的鼠标移动
            mouse_event(MOUSEEVENTF_MOVE, mouse.ptXY.x, mouse.ptXY.y, 0, GetMessageExtraInfo());
            break;
        }
        lstPacket.push_back(CPacket(5, NULL, 0));
        return 0;
    }

    int SendScreen(std::list<CPacket>& lstPacket, CPacket& inPacket) {
        CImage screen;//GDI(全局设备接口)
        HDC hScreen = ::GetDC(NULL);//获取设备上下文（整个屏幕）句柄，HDC(Handle to device context
        //::表示是全局函数，即需要创建对象就可以直接调用该函数，且该函数定义在全局命名空间中。
        //获取每个像素的位数，屏幕高度和宽度
        int nBitPerPixel = GetDeviceCaps(hScreen, BITSPIXEL);
        int nWidth = GetDeviceCaps(hScreen, HORZRES);
        int nHeight = GetDeviceCaps(hScreen, VERTRES);
        screen.Create(nWidth, nHeight, nBitPerPixel);//用上面的参数来创建screen图片对象
        //BitBlt(screen.GetDC(), 0, 0, 2560, 1440, hScreen, 0, 0, SRCCOPY); //使用 BitBlt 函数来将屏幕的图像复制到 screen 对象中
        BitBlt(screen.GetDC(), 0, 0, nWidth, nHeight, hScreen, 0, 0, SRCCOPY); //使用 BitBlt 函数来将屏幕的图像复制到 screen 对象中
        ReleaseDC(NULL, hScreen);
        HGLOBAL hMem = GlobalAlloc(GMEM_MOVEABLE, 0);//分配全局内存对象，准备使用后续内存流
        if (hMem == NULL)//全局内存分配失败
            return -1;
        IStream* pStream = NULL;//在分配的全局内存上创建一个 IStream 接口
        HRESULT ret = CreateStreamOnHGlobal(hMem, TRUE, &pStream);
        if (ret == S_OK) {
            screen.Save(pStream, Gdiplus::ImageFormatPNG);//将一个屏幕截图保存为PNG格式的图片到一个流对象中
            LARGE_INTEGER bg = { 0 };
            pStream->Seek(bg, STREAM_SEEK_SET, NULL);//重置流的内部位置指针到流的开始处
            PBYTE pData = (BYTE*)GlobalLock(hMem);//对一个全局内存对象进行锁定，并获取到指向内存对象数据的指针。
            SIZE_T nSize = GlobalSize(hMem);
            lstPacket.push_back(CPacket(6, pData, nSize));
            GlobalUnlock(hMem);
        }

        //screen.Save(_T("test2023.png"),Gdiplus::ImageFormatPNG);
        /*
        TRACE("png %d\r\n", GetTickCount64() - tickpng);
        DWORD tickjpg = GetTickCount64();
        screen.Save(_T("test2023.jpg"),Gdiplus::ImageFormatPNG);
        TRACE("jpg %d\r\n", GetTickCount64() - tickjpg);
        */
        pStream->Release();
        GlobalFree(hMem);
        screen.ReleaseDC();
        return 0;
    }
    int LockMachine(std::list<CPacket>& lstPacket, CPacket& inPacket) {
        if (dlg.m_hWnd == NULL || dlg.m_hWnd == INVALID_HANDLE_VALUE) {//dlg的句柄为空或无效
            //_beginthread 创建的线程应该自行结束，因此在该线程开始后，LockMachine 函数将立即结束而不等待新线程的结束
            //_beginthread(threadLockDlg, 0, NULL);//_beginthread创建新线程，用函数指针threadLockDlg指向线程应该执行的函数
            _beginthreadex(NULL, 0, &CCommand::threadLockDlg, this, 0, &threadid);
            TRACE("threadid=%d\r\n", threadid);
        }
        lstPacket.push_back(CPacket(7, NULL,0));
        return 0;
    }

    int UnlockMachine(std::list<CPacket>& lstPacket, CPacket& inPacket) {
        //dlg.SendMessage(WM_KEYDOWN,0x41, LPARAM(001E0001));
        //::SendMessage(dlg.m_hWnd, WM_KEYDOWN, 0x41, 0x01E0001);
        PostThreadMessage(threadid, WM_KEYDOWN, 0x41, 0);//将一个消息(键盘)投递到指定线程(threadid)―的消息队列中
        //消息是跟着线程来的，不是跟着对话框，句柄来的
        lstPacket.push_back(CPacket(8, NULL, 0));
        return 0;
    }

    int TestConnect(std::list<CPacket>& lstPacket, CPacket& inPacket) {
        lstPacket.push_back(CPacket(1981, NULL, 0));
        return 0;
    }

    int DeleteLocalFile(std::list<CPacket>& lstPacket, CPacket& inPacket)
    {
        std::string strPath = inPacket.strData;
        TCHAR sPath[MAX_PATH] = _T("");//使用系统定义的 MAX_PATH（通常为 260）声明一个 TCHAR 类型的数组 sPath，用于存储转换为宽字符格式后的文件路径。
        //_T("") 是一个宏，它用于根据项目是否支持 Unicode 而生成适当编码的字符串常量
        //mbstowcs(sPath, strPath.c_str(), strPath.size());会乱码
        //使用 mbstowcs 函数把 strPath 变量中存储的多字节字符字符串转换成宽字符字符串，并将结果存储到 sPath 数组。这是必要的，因为 Windows API 函数 DeleteFile 可能需要一个宽字符字符串作为参数，这取决于你的项目设置。
        MultiByteToWideChar(
            CP_ACP, 0, strPath.c_str(), strPath.size(), sPath,
            sizeof(sPath) / sizeof(TCHAR));
        DeleteFileA(strPath.c_str());
        //调用 Windows API 函数 DeleteFile 删除名为 sPath 的文件。如果函数成功，文件将被标记为删除，并在最后一个句柄关闭时删除。
        lstPacket.push_back(CPacket(9, NULL, 0));
        return 0;
    }
};

